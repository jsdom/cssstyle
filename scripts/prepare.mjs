import fs from "node:fs/promises";
import path from "node:path";
import css from "@webref/css";
import { definitionSyntax } from "css-tree";

const { dirname } = import.meta;
const [dateToday] = new Date().toISOString().split("T");

const { properties, types } = await css.listAll();
const definitions = new Map(
  properties.map((definition) => {
    delete definition.extended;
    return [definition.name, definition];
  })
);
const syntaxes = new Map(types.map((definition) => [`<${definition.name}>`, definition]));

const propertyFiles = await fs.readdir(path.resolve(dirname, "../lib/properties"));
const implementedProperties = new Map(propertyFiles.map((file) => [file.replace(/\.js$/, ""), file]));

const caseSensitiveTypes = ["custom-ident", "dashed-ident", "string"];
const functionTypes = ["color", "image"];
const dimensionTypes = [
  "angle",
  "angle-percentage",
  "flex",
  "frequency",
  "frequency-percentage",
  "integer",
  "length",
  "length-percentage",
  "number",
  "percentage",
  "ratio",
  "time",
  "time-percentage"
];
const typeList = new Set([...caseSensitiveTypes, ...functionTypes, ...dimensionTypes]);

await Promise.all([generateDefinitions(), generateDescriptors()]);

/**
 * Generates property definitions file.
 *
 * @returns {Promise<void>}
 */
function generateDefinitions() {
  const output = `"use strict";
// autogenerated - ${dateToday}

module.exports = new Map(${JSON.stringify([...definitions], null, 2)});
`;
  return fs.writeFile(path.resolve(dirname, "../lib/generated/propertyDefinitions.js"), output);
}

/**
 * Generates property descriptors file.
 *
 * @returns {Promise<void>}
 */
function generateDescriptors() {
  const requires = [];
  const descriptors = [];
  for (const [canonicalProperty, { legacyAliasOf, styleDeclaration, syntax }] of definitions) {
    const camelizedProperty = dashedToCamelCase(canonicalProperty);
    const camelizedAliasProperty = legacyAliasOf ? dashedToCamelCase(legacyAliasOf) : "";
    if (implementedProperties.has(camelizedProperty)) {
      requires.push(
        `const ${camelizedProperty} = require("../properties/${implementedProperties.get(camelizedProperty)}");`
      );
      for (const property of styleDeclaration) {
        descriptors.push(`"${property}": ${camelizedProperty}.descriptor`);
      }
    } else if (implementedProperties.has(camelizedAliasProperty)) {
      // No need to add to `requires` since the non-alias branch of the outer
      // loop will ensure the corresponding handler file is included there.
      for (const property of styleDeclaration) {
        descriptors.push(`"${property}": ${camelizedAliasProperty}.descriptor`);
      }
    } else {
      const opts = JSON.stringify(createDescriptorOpts(syntax));
      for (const property of styleDeclaration) {
        descriptors.push(`"${property}": createGenericPropertyDescriptor("${canonicalProperty}", ${opts})`);
      }
    }
  }
  const output = `"use strict";
// autogenerated - ${dateToday}

${requires.sort().join("\n")}
const { createGenericPropertyDescriptor } = require("../utils/propertyDescriptors.js");

module.exports = {
  ${descriptors.join(",\n  ")}
};
`;
  return fs.writeFile(path.resolve(dirname, "../lib/generated/propertyDescriptors.js"), output);
}

/**
 * Creates property descriptor options.
 *
 * @param {string} syntax - The CSS syntax definition.
 * @returns {object} The property descriptor options object.
 */
function createDescriptorOpts(syntax) {
  const opts = new Map([["caseSensitive", false]]);
  const collectedTypes = collectTypes(syntax);
  if (collectedTypes.size) {
    for (const type of caseSensitiveTypes) {
      if (collectedTypes.has(type)) {
        opts.set("caseSensitive", true);
        break;
      }
    }
    const dimensions = new Map();
    for (const key of dimensionTypes) {
      if (collectedTypes.has(key)) {
        const { opts: keyOpts } = collectedTypes.get(key);
        const opt = {};
        if (keyOpts) {
          const { max, min } = keyOpts;
          if (max !== undefined) {
            opt.max = max;
          }
          if (min !== undefined) {
            opt.min = min;
          }
        }
        let type;
        switch (key) {
          case "angle":
          case "angle-percentage": {
            type = "angle";
            break;
          }
          case "integer":
          case "number": {
            type = "number";
            break;
          }
          case "length":
          case "length-percentage": {
            type = "length";
            break;
          }
          case "percentage": {
            type = "percentage";
            break;
          }
          default: {
            type = "dimension";
          }
        }
        opt.type = type;
        dimensions.set(type, opt);
      }
    }
    if (dimensions.size) {
      opts.set("dimensionTypes", Object.fromEntries(dimensions));
    }
    const functions = new Map();
    for (const type of functionTypes) {
      if (collectedTypes.has(type)) {
        functions.set(type, type);
      }
    }
    if (functions.size) {
      opts.set("functionTypes", Object.fromEntries(functions));
    }
  }
  return Object.fromEntries(opts);
}

/**
 * Collects CSS data types from a syntax definition.
 *
 * @param {string} syntax - The CSS syntax definition.
 * @returns {Map} The collection of types.
 */
function collectTypes(syntax) {
  const collectedTypes = new Map();
  if (!syntax) {
    return collectedTypes;
  }
  const ast = definitionSyntax.parse(syntax);
  if (ast.type === "Group") {
    const subTypeList = new Set();
    const propertyList = new Set();
    definitionSyntax.walk(ast, {
      enter(node) {
        const { name, type } = node;
        if (type === "Type") {
          if (typeList.has(name)) {
            collectedTypes.set(name, node);
          } else if (!name.endsWith("()")) {
            subTypeList.add(name);
          }
        } else if (type === "Property") {
          propertyList.add(name);
        }
      }
    });
    if (subTypeList.size) {
      for (const type of subTypeList) {
        const typeKey = `<${type}>`;
        if (syntaxes.has(typeKey)) {
          const { syntax: typeSyntax } = syntaxes.get(typeKey);
          const expandedList = collectTypes(typeSyntax);
          if (expandedList.size) {
            for (const [key, value] of expandedList) {
              collectedTypes.set(key, value);
            }
          }
        }
      }
    }
    if (propertyList.size) {
      for (const property of propertyList) {
        if (definitions.has(property)) {
          const { syntax: propertySyntax } = definitions.get(property);
          const expandedList = collectTypes(propertySyntax);
          if (expandedList.size) {
            for (const [key, value] of expandedList) {
              collectedTypes.set(key, value);
            }
          }
        }
      }
    }
  }
  return collectedTypes;
}

/**
 * Utility to translate from `border-width` to `borderWidth`.
 * NOTE: For values prefixed with webkit, e.g. `-webkit-foo`, we need to provide
 * both `webkitFoo` and `WebkitFoo`. Here we only return `webkitFoo`.
 *
 * @param {string} dashed - The dashed property name.
 * @returns {string} The camel cased property name.
 */
function dashedToCamelCase(dashed) {
  if (dashed.startsWith("--")) {
    return dashed;
  }
  let camel = "";
  let nextCap = false;
  // Skip leading hyphen in vendor prefixed value, e.g. `-webkit-foo`.
  let i = /^-webkit-/.test(dashed) ? 1 : 0;
  for (; i < dashed.length; i++) {
    if (dashed[i] !== "-") {
      camel += nextCap ? dashed[i].toUpperCase() : dashed[i];
      nextCap = false;
    } else {
      nextCap = true;
    }
  }
  return camel;
}
