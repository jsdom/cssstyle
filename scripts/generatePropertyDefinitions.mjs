import fs from "node:fs";
import path from "node:path";
import css from "@webref/css";
import { definitionSyntax } from "css-tree";

const { properties, types } = await css.listAll();
const syntaxes = new Map([...types.map((definition) => [`<${definition.name}>`, definition])]);
const definitions = properties.map(prepareDefinition);

const [dateTodayFormatted] = new Date().toISOString().split("T");
const output = `"use strict";
// autogenerated - ${dateTodayFormatted}

module.exports = new Map(${JSON.stringify(definitions, null, 2)});
`;

const { dirname } = import.meta;
fs.writeFileSync(path.resolve(dirname, "../lib/generated/propertyDefinitions.js"), output);

/**
 * Prepares a property definition.
 *
 * @param {object} definition - The CSS property definition object.
 * @returns {Array} A key-value pair consisting of the property name and the property definition.
 */
function prepareDefinition(definition) {
  const { name, syntax } = definition;
  const caseSensitiveTypes = ["custom-ident", "dashed-ident", "string"];
  const typeList = collectTypes(syntax, new Set(caseSensitiveTypes));
  if (typeList.size) {
    for (const type of caseSensitiveTypes) {
      if (typeList.has(type)) {
        definition.caseSensitive = true;
        break;
      }
    }
  }
  delete definition.extended;
  return [name, definition];
}

/**
 * Collects CSS data types from syntax.
 * NOTE: Returns a map as we plan to collect dimensions etc. in the near future.
 *
 * @param {string} syntax - The CSS syntax definition.
 * @param {Set} nameList - The name of types to collect.
 * @returns {Map} The collection of types.
 */
function collectTypes(syntax, nameList) {
  const typeList = new Map();
  try {
    const ast = definitionSyntax.parse(syntax);
    if (ast.type === "Group") {
      const subList = new Set();
      definitionSyntax.walk(ast, {
        enter(node) {
          if (node.type === "Type") {
            if (nameList.has(node.name)) {
              typeList.set(node.name, node);
            } else if (!node.name.endsWith("()")) {
              subList.add(node.name);
            }
          }
        }
      });
      if (subList.size) {
        for (const type of subList) {
          const { syntax: typeSyntax } = syntaxes.get(`<${type}>`);
          const expandedList = collectTypes(typeSyntax, nameList);
          if (expandedList.size) {
            for (const [key, value] of expandedList) {
              typeList.set(key, value);
            }
          }
        }
      }
    }
  } catch {
    // ignore
  }
  return typeList;
}
